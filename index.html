<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Paket Messer Pro (Instant)</title>
    <style>
        body { margin: 0; background: #000; font-family: sans-serif; overflow: hidden; color: white; touch-action: none; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; width: 100%; height: 100%; object-fit: cover; }
        
        /* Die Lupe */
        #magnifier { 
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            width: 180px; height: 180px; border: 4px solid #007bff; border-radius: 90px;
            z-index: 100; overflow: hidden; display: none; background: #000;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); pointer-events: none;
        }
        #mag-canvas { width: 100%; height: 100%; }

        #ui-top { position: absolute; top: 0; width: 100%; z-index: 20; background: rgba(0,0,0,0.8); padding: 15px 0; text-align: center; border-bottom: 2px solid #007bff; }
        .status { font-size: 1.1rem; font-weight: bold; color: #ffc107; margin-bottom: 5px; }
        .instr { font-size: 0.9rem; color: #00d4ff; padding: 0 10px; }
        
        .controls { position: absolute; bottom: 30px; width: 100%; z-index: 20; display: flex; justify-content: center; gap: 10px; }
        button { padding: 15px 20px; font-size: 1rem; border-radius: 12px; border: none; font-weight: bold; color: white; cursor: pointer; background: #444; }
        #btn-main { background: #007bff; min-width: 140px; }
        #btn-reset { background: #dc3545; }
    </style>
</head>
<body>

<div id="magnifier">
    <canvas id="mag-canvas" width="180" height="180"></canvas>
    <div style="position:absolute; top:90px; left:0; width:180px; height:2px; background:rgba(255,0,0,0.5);"></div>
    <div style="position:absolute; top:0; left:90px; width:2px; height:180px; background:rgba(255,0,0,0.5);"></div>
</div>

<div id="container">
    <video id="videoInput" playsinline muted></video>
    <canvas id="canvasOutput"></canvas>
</div>

<div id="ui-top">
    <div id="status" class="status">Initialisiere...</div>
    <div id="instr" class="instr">Warte auf Kamera...</div>
</div>

<div class="controls">
    <button id="btn-main" onclick="handleMainAction()">FOTO AUFNEHMEN</button>
    <button onclick="undo()">RÜCKGÄNGIG</button>
    <button id="btn-reset" onclick="resetApp()">RESET</button>
</div>

<script>
// Zustände: CALIB_1, CALIB_2 (Blatt), SNAP (Kamera), MEASURE (Punkte setzen), RESULT
let state = 'CALIB_1';
let pxPerCm = localStorage.getItem('px_cm_pure') ? parseFloat(localStorage.getItem('px_cm_pure')) : null;
if (pxPerCm) state = 'SNAP';

let points = [];
let calibPoints = [];
let snapshot = null;
let activePointIndex = -1;

const video = document.getElementById('videoInput');
const canvas = document.getElementById('canvasOutput');
const ctx = canvas.getContext('2d');
const mag = document.getElementById('magnifier');
const magCtx = document.getElementById('mag-canvas').getContext('2d');

async function initCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: "environment", width: { ideal: 1920 }, height: { ideal: 1080 } } 
        });
        video.srcObject = stream;
        await video.play();
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        updateUI();
        requestAnimationFrame(mainLoop);
    } catch (err) {
        document.getElementById('status').innerText = "Kamera-Fehler!";
        alert("Bitte Kamera-Zugriff erlauben.");
    }
}

function updateUI() {
    const s = document.getElementById('status');
    const ins = document.getElementById('instr');
    const b = document.getElementById('btn-main');
    
    const texts = {
        'CALIB_1': ['KALIBRIERUNG', 'Tippe auf die linke Ecke der LANGEN Seite (A4)'],
        'CALIB_2': ['KALIBRIERUNG', 'Tippe auf die rechte Ecke der LANGEN Seite (A4)'],
        'SNAP': ['BEREIT', 'Paket anvisieren und Foto machen'],
        'MEASURE': ['PUNKTE SETZEN', 'Setze die 4 Ecken des Pakets'],
        'RESULT': ['ERGEBNIS', 'Du kannst Punkte ziehen, um sie zu verfeinern']
    };
    
    const [title, instruction] = texts[state] || ["", ""];
    s.innerText = title;
    ins.innerText = instruction;
    b.style.display = (state === 'SNAP' || state === 'RESULT') ? "block" : "none";
    b.innerText = (state === 'SNAP') ? "FOTO AUFNEHMEN" : "NEUES FOTO";
}

function mainLoop() {
    if (state.startsWith('CALIB') || state === 'SNAP') {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        calibPoints.forEach(p => drawMarker(p, "#ffc107"));
    } else if (snapshot) {
        ctx.putImageData(snapshot, 0, 0);
        drawParcel();
    }
    requestAnimationFrame(mainLoop);
}

function handleMainAction() {
    if (state === 'SNAP') {
        snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
        state = 'MEASURE';
    } else {
        points = []; snapshot = null; state = 'SNAP';
    }
    updateUI();
}

canvas.addEventListener('touchstart', (e) => {
    const pos = getTouchPos(e);
    if (state.startsWith('CALIB')) {
        calibPoints.push(pos);
        if (state === 'CALIB_1') state = 'CALIB_2';
        else {
            const d = Math.hypot(calibPoints[0].x - calibPoints[1].x, calibPoints[0].y - calibPoints[1].y);
            pxPerCm = d / 29.7;
            localStorage.setItem('px_cm_pure', pxPerCm);
            state = 'SNAP';
        }
    } else if (state === 'MEASURE' || state === 'RESULT') {
        activePointIndex = points.findIndex(p => Math.hypot(p.x - pos.x, p.y - pos.y) < 40);
        if (activePointIndex === -1 && points.length < 4) {
            points.push(pos);
            activePointIndex = points.length - 1;
        }
    }
    updateUI();
});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const pos = getTouchPos(e);
    if (activePointIndex !== -1) {
        points[activePointIndex] = pos;
        if (points.length === 4) state = 'RESULT';
    }
    
    // Lupe anzeigen
    mag.style.display = 'block';
    const z = 80;
    magCtx.drawImage(canvas, pos.x - z/2, pos.y - z/2, z, z, 0, 0, 180, 180);
});

canvas.addEventListener('touchend', () => {
    mag.style.display = 'none';
    activePointIndex = -1;
    updateUI();
});

function getTouchPos(e) {
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    return { x: (t.clientX - rect.left) * (canvas.width / rect.width), y: (t.clientY - rect.top) * (canvas.height / rect.height) };
}

function drawMarker(p, col) {
    ctx.fillStyle = col; ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
}

function drawParcel() {
    points.forEach((p, i) => drawMarker(p, (i === activePointIndex) ? "red" : "white"));
    if (points.length >= 2) renderLine(points[0], points[1], "#ff0", "H");
    if (points.length >= 3) renderLine(points[0], points[2], "#07f", "B");
    if (points.length >= 4) {
        renderLine(points[0], points[3], "#0f0", "L");
        const p0=points[0], p1=points[1], p2=points[2], p3=points[3];
        const h={x:p1.x-p0.x, y:p1.y-p0.y}, b={x:p2.x-p0.x, y:p2.y-p0.y}, l={x:p3.x-p0.x, y:p3.y-p0.y};
        ctx.setLineDash([5,5]); ctx.lineWidth=3;
        const line=(a,b,c)=>{ctx.strokeStyle=c; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();};
        line(p1, {x:p1.x+b.x, y:p1.y+b.y}, "#07f"); line(p1, {x:p1.x+l.x, y:p1.y+l.y}, "#0f0");
        line(p2, {x:p2.x+h.x, y:p2.y+h.y}, "#ff0"); line(p3, {x:p3.x+h.x, y:p3.y+h.y}, "#ff0");
    }
}

function renderLine(p1, p2, col, lab) {
    const d = Math.hypot(p1.x-p2.x, p1.y-p2.y) / pxPerCm;
    ctx.strokeStyle = col; ctx.lineWidth = 12; ctx.setLineDash([]);
    ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
    ctx.fillStyle = "black"; ctx.font = "bold 28px Arial";
    ctx.fillText(`${lab}: ${d.toFixed(1)}cm`, (p1.x+p2.x)/2 - 30, (p1.y+p2.y)/2);
}

function undo() { points.pop(); state = (points.length < 4) ? 'MEASURE' : 'RESULT'; updateUI(); }
function resetApp() { localStorage.clear(); location.reload(); }

window.onload = initCamera;
</script>
</body>
</html>